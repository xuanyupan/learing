# JVM类加载机制

- 一个类从被加载到虚拟机内存到卸载出内存，一共要经历加载、验证、准备、解析、初始化、使用和卸载7个阶段。**类加载经历前五个阶段就是加载、验证、准备、解析、初始化**。

- **加载**：通过类加载器加载，在HotSpot虚拟机中，class对象是存在方法区，而不是JVM虚拟机堆；在虚拟机中，程序主动使用一个类，但是这个类还没有加载到内存的时候，就会进行加载操作，知道初始化完成。三个任务：

  > 1.通过类的权限定名来获取定义此类的二进制字节流；
  >
  > 2.将这个字节流锁代表的静态存储结构转化为方法区的运行时数据结构
  >
  > 3.在内存中生成这个类的类对象，作为方法区这个类的各个数据的访问入口。

- **验证**：在加载之后要对class文件中的内容进行验证，看是否符合规范。

  > 1.验证文件格式如：魔数，版本号一类
  >
  > 2.元数据验证，类中字段是否矛盾，是否有父类，因为除了Object所有类都有父类
  >
  > 3.字节码验证，判断一些数据流看程序语义是否合法
  >
  > 4.符号引用验证，判断全限定名是否可以找到对应的类，访问权限一类。

- **准备**：对类变量（就是被static修饰的变量）分配内存并设置初始值，就是对各种数据类型附初始值。

- **解析**：将常量池中的符号引用替换为直接引用的过程。解析，通常解析针对类，接口，字段，类方法，接口方法。方法类型，方法句柄和调用点限定符

  > 符号引用：使用一组符号来描述所引用的目标，可以是任何形式的字面量。static修饰的变量，就是我们常说的符号引用，在编译阶段符号引用都不知道自己引用类的实际内存地址，到了解析才知道。一个类中引用了另一个类，也是在解析的时候才知道被引用类的真实内存地址。
  >
  > 直接引用：可以是直接指向目标的指针，相对偏移量活是一个能间接定位到目标的句柄

- **初始化**：最后一步，只有以下5种情况进行初始化

  >1.遇到new，getstatic，putstatic或者invokestatic这4条字节码指令。如果类没有进行过初始化，就需要进行初始化
  >
  >2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行初始化，需要初始化
  >
  >3初始化一个类时，若他的父类没有初始化，需要先初始化他的父类
  >
  >4.虚拟机启动时，用户指定一个执行的主类（就是有main（）d的那个类），虚拟机会先初始化这个类
  >
  >5.emmm，这个我看书也有点懵。原话就是jdk1.7动态语言支持，如果java.lang.incoke.MethodHandle实例最后解析出来的解析结果是REF_getstatic,REF_putstatic,REF_invokestatic的方法句柄，且这个类没有初始化，所以需要初始化。这三个解析结果和上面1中的相似诶。