# java垃圾回收机制

判定为垃圾的标准，没有被其他对象引用，

判定为垃圾的算法，引用技术算法，对象有一个引用计数器，被引用则+1，完成-1，引用为0就可以回收。执行效率高，无法检测循环引用的情况。

可达性分析算法。判断引用链是否可达来判断，GC root。虚拟机栈中的引用对象，方法去中的常量引用对象，类静态属性引用对象，JNI引用对象，活跃线程引用对象。



垃圾回收算法。

标记清除算法。通过可达性算法来标记，对堆内存遍历，回收不可达的对象。会产生大量不连续碎片。

复制算法。分为对象面和空闲面，对象在对象面创建，存活的对象从对象面复制到空闲面上。解决了碎片化问题，对象存活率低问题，一般用于年轻代。

标记整理算法，标记，移动存活对象地址连续排列，适用于存活率高的场景，老年代。



分代收集算法。

年轻代，一般用复制算法。Eden区，两个Survivor区。尽可能快速手机掉年轻生命周期端的对象。8:1:1。对象如果在minorGC超过一定年龄就会进入老年代。survivor区存不下的会转到老年代，大的对象直接进入老年代。

老年代，利用标记清除标记整理。



触发Full GC，老年代空间不足，jdk7永久代不足，用元空间代替永久代的可以减少Full GC。从Minor GC晋升到老年代平均大小大于老年代的剩余空间,调用System.gc().



常见的垃圾收集器。

jvm运行模式，server与client两种。

年轻代的：

Serial：复制算法，单线程。使用时必须暂停其他所有暂停工作。client模式下默认年轻代收集器。

ParNew：多线程的Serial，单核执行不如serial，默认server的年轻代收集器

Parallel Scavenge：复制算法，多线程，尽可能缩短了停顿时间，更多关注吞吐量。吞吐量=代码运行时间/（代码运行时间+gc时间）。server年轻代收集器。

老年代：

Serial Old：标记整理算法，client，单线程

Paralled Old：多线程，吞吐量优先

CMS：标记清除算法，

G1：标记整理，并发并行，可以分代手机，控件整合，可预测停顿。不需要划分老年代和年轻代。